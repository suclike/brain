## Overview

One of the challenges in writing robust Android apps is the dynamic nature of changing inputs.   In traditional imperative programming models, values have to be explicitly set on variables for them to be updated.  If one dependent value changes, the value will not be updated without adding another line of code.   Consider the following example:

```java
// init variables
int i, j, k; 

// Init inputs
i = 1;
j = 2;

// Set output value
k = i + j;

// Update a dependent value
j = 4;
k = ?  // What should k be?
```

Traditional asynchronous programming approaches tend to rely on callbacks to update these changes, but this way can lead to a problem known as [callback hell](http://callbackhell.com/).  **_Reactive programming_** (see an intro [here](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)) addresses these issues by providing a framework to describe outputs to reflect their changing inputs.  RxJava, which is a port of the [Reactive Extensions](https://msdn.microsoft.com/en-us/data/gg577609.aspx) library from .NET, enables Android apps to be built in this style.

### Advantages

Here are a few advantages of using RxJava on Android:

 * **Simplifies the ability to chain async operations.**  If you need to make an API call that depends on another API call, you will likely end up implementing this call in the callback of the first one.  RxJava provides a way to avoid needing to creating [layers of callbacks](https://www.bignerdranch.com/blog/what-is-functional-reactive-programming/) to address this issue.  For this reason, RxJava became [popular within Netflix](http://www.infoq.com/presentations/rx-service-architecture) in 2014 for abstracting away the complexities of performing dependent API calls.

 * **Exposes a more explicit way for declaring how concurrent operations should operate.**  Although RxJava is  single-threaded by default, RxJava helps enable you to define more explicitly what type of threading models should be used for both background and callback tasks.  Since Android only allows UI updates on the main thread, using RxJava helps make the code more clear about what operations will be done to update the views. 

 * **Surfaces errors sooner.** One issue with [[AsyncTask|Creating-and-Executing-Async-Tasks]] is that errors that occur on the background thread are hard to pass along when updating the UI thread using the `onPostExecute()` method.  In addition, there are limitations in how many AsyncTasks can be dispatched concurrently as described in this [blog post](http://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/).  RxJava provides a way to enable these errors to be surfaced.

 * **Provides powerful constructs for manipulating streams of data.**  One mindset shift in using RxJava  is thinking about everything in terms of describing as data flows in the system.  Click events generated by the user, network calls, data updates from external sources all can all be described as asynchronous streams of data.  The power of RxJava is that it enables these streams to be transformed, filtered, or used to create new streams of data with only a few lines of code. 

## Setup

Setup your `app/build.gradle`:

```gradle
dependencies {
  compile 'io.reactivex:rxjava:1.0.16'
  compile 'io.reactivex:rxandroid:1.0.1'
}
```

## Creating Asynchronous Streams

RxJava defines the concept of an **Observable** and an **Observer**.  An Observable is emitting values over time, either as finite or infinite duration of time.  In the Android world, most of the time we are working with finite streams of data.

An **Observer** watches for result values emitted by the **Observable** .  When these events occur, the role of the observer is to respond to these events.  An Observable can be created from just any type of input.  For instance, it can a set of strings that should be iterated:

```java
Observable.just("a", "b", "c")  // generate an observable
```

Similar to the above example, the [[Retrofit|https://github.com/codepath/android_guides/wiki/Consuming-APIs-with-Retrofit#rxjava]] library simply [wraps a synchronous network call](https://github.com/square/retrofit/blob/master/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java##L152-L163) as an `Observable` type for use with RxJava.   Declaring the endpoints as `Observable` automatically does this work.

```java
public interface MyApiEndpointInterface {
  @GET("/users/{username}")
  Observable<User> getUser(@Path("username") String username);
}
```

We can then instantiate an instance of this interface and get back an `Observable` type:

```java
MyApiEndpointInterface apiService =
    retrofit.create(MyApiEndpointInterface.class);

Observable<User> call = apiService.getUser(username);
```

To implement an observer, the following interface must be defined:

```java
public interface Observer<T> {

    void onCompleted(); // will not be called if onError() is called

    void onError(Throwable e); 
    void onNext(T t);

}
```

Note that an `Observer` is a generic type.  It must be represent the type of value that the `Observable` will emit.  For an observer to start watching an observable that will generate string types, it must subscribe to it:

```java
Observable.just("a", "b", "c").subscribe(new Observer<String>() {
    @Override
    public void onCompleted() {
                                                         
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onNext(String s) {

     }
});
```

### Schedulers

RxJava is synchronous by default, but work can be defined asynchronously using schedulers.  For instance, we can define that the network call should be done on a background thread, but the callback should be done on the main UI thread.  To define where the work is done, we can use `observeOn()` with Retrofit:

```java
Observable<User> call = apiService.getUser(username);
call.observeOn(AndroidSchedulers.mainThread())
```

The RxAndroid library also includes `AndroidSchedulers.mainThread()` for allowing callbacks to be fired on the main UI thread. 

Using schedulers relies on queuing the work through bounded or unbounded thread pools.  Here are a few options available that come with RxJava.  See [this link](http://reactivex.io/RxJava/javadoc/rx/schedulers/Schedulers.html) for all the possible options.  

|  Name                      | Description                                            |
|:--------------------------:|:------------------------------------------------------:|
| Schedulers.computation()   | fixed number of threads (= to # CPU's)                 |                          
| Schedulers.immediate()     | current thread                                         |                          
| Schedulers.io()            | backed by a current                                    |          
| Schedulers.newThread()     | create a new thread                                    | 
| Schedulers.tramponline()   | schedule work on the current thread but put on a queue |

### Chaining Observables

For a better understanding about how subscriptions can be chained and how RxJava works in general, it's best to first to understand what happens beneath the surfaces when this `subscribe()` call is made.   Beneath the covers `Subscriber` objects are created.  If we wish to chain the input, there are various **operators** that are available that map one `Subscriber` type to another.  

For more context, watch this [video talk](https://vimeo.com/144812843).

## Replacing AsyncTask

```java
public Observable<Bitmap> getImageNetworkCall() {
    // Insert network call here!
}

Subscription subscription = getImageNetworkCall()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer<Bitmap>() {

        @Override
        public void onCompleted() {
             // Update user interface if needed
        }

        @Override
        public void onError() {
             // Update user interface to handle error
        }

        @Override
        public void onNext(Bitmap bitmap) {
             // Handle result of network request
        }
});
```

## References

* <https://github.com/ReactiveX/RxJava/wiki/The-RxJava-Android-Module>
* <http://saulmm.github.io/when-Iron-Man-becomes-Reactive-Avengers2/>
* <http://blog.stablekernel.com/replace-asynctask-asynctaskloader-rx-observable-rxjava-android-patterns/>
* <https://www.youtube.com/watch?v=_t06LRX0DV0/>
* <https://vimeo.com/144812843>
* <http://code.hootsuite.com/asynchronous-android-programming-the-good-the-bad-and-the-ugly/>
* <https://www.youtube.com/watch?v=va1d4MqLUGY&feature=youtu.be/>
* <http://www.slideshare.net/TimoTuominen1/rxjava-architectures-on-android-android-livecode-berlin/>
* <https://www.youtube.com/watch?v=va1d4MqLUGY&feature=youtu.be/>
* <https://speakerdeck.com/benjchristensen/reactive-streams-with-rx-at-javaone-2014>
* <http://www.philosophicalhacker.com/2015/06/12/an-introduction-to-rxjava-for-android/>
* <http://www.oreilly.com/programming/free/files/rxjava-for-android-app-development.pdf>
* <https://medium.com/@LiudasSurvila/droidcon-2015-london-part-1-698a6b750f30#.tvinpqa2q>
* <https://speakerdeck.com/passsy/get-reactive>